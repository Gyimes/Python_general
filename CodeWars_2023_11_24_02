#instructions
#Let's make it so Bob never misses another interesting number. We've hacked into his car's computer, and we have a box hooked up that reads mileage numbers. We've got a box glued to his dash that lights up yellow or green depending on whether it receives a 1 or a 2 (respectively).
#It's up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a 2 if the number is "interesting" (see below), a 1 if an interesting number occurs within the next two miles, or a 0 if the number is not interesting.
#Note: In Haskell, we use No, Almost and Yes instead of 0, 1 and 2.
#"Interesting" Numbers
#Interesting numbers are 3-or-more digit numbers that meet one or more of the following criteria:
#Any digit followed by all zeros: 100, 90000
#Every digit is the same number: 1111
#The digits are sequential, incementing†: 1234
#The digits are sequential, decrementing‡: 4321
#The digits are a palindrome: 1221 or 73837
#The digits match one of the values in the awesome_phrases array
#† For incrementing sequences, 0 should come after 9, and not before 1, as in 7890.
#‡ For decrementing sequences, 0 should come after 1, and not before 9, as in 3210.
#Error Checking
#A number is only interesting if it is greater than 99!
#Input will always be an integer greater than 0, and less than 1,000,000,000.
#The awesomePhrases array will always be provided, and will always be an array, but may be empty. (Not everyone thinks numbers spell funny words...)
#You should only ever output 0, 1, or 2.





def is_interesting(number, awesome_phrases):
    if number < 100: # We only care for numbers that are 3 digits at least
        if number in [98, 99]:
            return(1)
        else:
            return(0)
    
    #check if neighbours are palindromes
    def is_palindrome(number):
        str_number = str(number)
        return str_number == str_number[::-1]

    def has_palindrome_neighbor(number):
        for i in range(-2, 3):
            neighbor = number + i
            if is_palindrome(neighbor):
                return True
        return False
    
    #Create ideal versions of the number
    
    def create_ideals(number):
        ideals = []
        x = [int(i) for i in str(number)]

        #followed by zeros
        ideals.append(x[0]*10**(len(x)-1))

        #all the same number
        samenum = 0
        for i in range(1,len(x)+1):
            samenum += x[0]*10**(len(x)-i)
        ideals.append(samenum)

        #ascending sequence
        def ascnumcreator(x):
            ascnumvals = []
            for i in range(0, len(x)):
                if x[0]+(i*1) > 9:
                    val = x[0]+(i*1)-10
                else:
                    val = x[0]+(i*1)
                ascnumvals.append(val)
            ascnum = ''.join(map(str, ascnumvals))
            return(int(ascnum))

        ideals.append(ascnumcreator(x))
        #descending sequence
        def descnumcreator(x):
            descnumvals = []
            for i in range(0, len(x)):
                if x[0]-(i*1) < 0:
                    val = x[0]+(i*1)+10
                else:
                    val = x[0]-(i*1)
                descnumvals.append(val)
            descnum = ''.join(map(str, descnumvals))
            return(int(descnum))
        ideals.append(descnumcreator(x))
        #palindrome
        y = x.copy()
        for i in range(0, (int(len(x)/2)+1)):
            y[-i-1] = y[i]
        ideals.append(int(''.join(map(str, y))))

        return(ideals)
    
    ids = create_ideals(number = number) + awesome_phrases
    almost = [x - 1 for x in ids] + [x + 1 for x in ids] + [x - 2 for x in ids] + [x + 2 for x in ids]

    if number in ids:
        return(2)
    elif number in almost:
        return(1)
    else:
        if has_palindrome_neighbor(number):
            if is_palindrome(number):
                 return(2)
            else:
                return(1)
        else:
            return(0)
